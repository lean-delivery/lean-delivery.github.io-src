How to add SonarQube to CI process
##############################################
:date: 2019-11-26 17:56
:author: Dzmitry Rudnouski

**SonarQube** - is a tool for static code analysis. General concept you may get from this `short article <https://en.wikipedia.org/wiki/SonarQube>`_ on
wiki. In addition to article I'll tell more about SonarQube versions and plugins.

Как отдельное приложение SonarQube доступен в виде бесплатной community
версии и трех платных
`версий <https://www.sonarsource.com/plans-and-pricing/>`_ - developer,
enterprise и data center. Кроме этого, в наличии платный SaaS
вариант - `sonarcloud.io <https://sonarcloud.io/>`_, который, тем не менее, бесплатен для публичных
проектов. Так что, если вы являетесь владельцем open source проекта на
GitHub, Bitbucket или Azure DevOps, рекомендую воспользоваться этой
возможностью (и могу опубликовать краткую инструкцию по настройке).
Кстати, вот вам живой пример: код сайта, который вы сейчас читаете,
проверяется в sonarcloud.io - `lean-delivery.github.io-src <https://sonarcloud.io/dashboard?id=lean-delivery_lean-delivery.github.io-src>`_.

Из коробки SonarQube предоставляет около 20 своих (коробочных) плагинов,
в основном языковых, количество меняется от версии к версии. Кроме этого
доступно около 60 сторонних плагинов различных типов:

-  языковые - например groovy, yaml
-  внешние анализаторы - например checkstyle, findbugs, pmd, ansible lint
-  интеграция - например аутентификация через Gitlab, Bitbucket
-  покрытие кода
-  локализация и другие

Стоит сказать, что бесплатная community версия отличается по
возможностям от бесплатной sonarcloud.io. Вот их сравнение:

.. image:: {filename}/images/sonarqube_table1.png

Дальше в этой статье мы будем говорить о бесплатной community версии.
Актульные версии на данный момент – 7.9.1 LTS и 8.0.

**Установка.**

Установить SonarQube можно несколькими способами.

1. Вручную. Просто не советую тратить на это время.

2. Взять официальный `образ <https://hub.docker.com/_/sonarqube>`_ с
   dockerhub. Сам я этот способ не использую, но если интересно, могу
   сравнить с третьим способом.

3. Установить с помощью нашей `ansible-sonarqube <https://github.com/lean-delivery/ansible-role-sonarqube>`_ роли.

Расскажу подробнее про последний способ. Прочтите readme, возьмите оттуда
пример плейбуки и подправьте ее под свои нужды. Она установит SonarQube
и то, что ему требуется для работы: java (используя нашу
`ansible-java <https://github.com/lean-delivery/ansible-role-java>`_ роль), postgresql базу и nginx (для https).

Кстати, об упомянутой java роли. Она вам может пригодится не только для установки SonarQube, но и во многих других случаях. Это лучшая роль LDI проекта и лучшая java роль на Ansible Galaxy. Обратите внимание на количество поддерживаемых разновидностей JDK/JRE и на количество поддерживаемых платформ.

Для установки SonarQube потребуется машина минимум с 4 Gb памяти – например t3a.medium в AWS.

Обратите внимание, что кроме установки, роль может выполнить некоторые конфигурационные действия:

-  смигрировать базу – потребуется, если у вас уже есть SonarQube, а вы
   устанавливаете более свежую версию поверх
-  добавить вебхук на Jenkins (об этом ниже)
-  импортировать кастомные профили с правилами (об этом тоже ниже)
-  настроить аутентификацию через LDAP

**Конфигурирование.**

Первое, что надо сделать – сменить дефолтный пароль для admin
пользователя в **Administration > Security > Users**. А вот что бывает,
когда об этом забываешь - `UK cell giant EE left a critical code system
exposed with a default
password. <https://www.zdnet.com/article/mobile-giant-left-code-system-online-default-password/>`_
Кстати, мы планируем добавить в роль возможность смены дефолтного пароля.

Кроме смены пароля добавьте токен admin пользователю, он понадобится в
дальнейшем.

Постороннее лицо уже не может зайти под дефолтными admin/admin, но все еще способно видеть ваш код, не заходя в систему.
Поэтому следующий шаг – закрытие гостевого доступа через меню
**Administration > Configuration > Security > Force user
authentication.** Эта возможность тоже будет добавлена в роль.

Если в SonarQube кроме вас будут ходить и другие члены команды, имеет смысл
настроить аутентификацию через LDAP (есть в роли), GitHub, Bitbucket,
Gitlab и т.д.

Переходим к настройке языковых профилей в меню **Quality Profiles**.
Каждый языковой плагин предоставляет свой built-in профиль – это просто набор активных и неактивных правил, в соответсвии с которыми проверяется код.
Кроме правил в профиле могут находиться шаблоны, из которых вы можете создать свои правила.
Вот пример – built-in `профиль <https://sonarcloud.io/organizations/lean-delivery/rules?activation=true&qprofile=AW0kegFj4oPgLAsgGJ2v>`_ языка Python
(здесь и дальше для иллюстрации я буду давать ссылки на SonarCloud, но в SonarQube все выглядит точно так же). 

Если у вас есть свои кастомные профили – вы можете их импортировать еще
на этапе инсталляции с помощью роли и затем вручную назначить используемыми по умолчанию. Если кастомных профилей нет – отставьте
все как есть, и по умолчанию будут использоваться Built-in профили. Скорее
всего в дальнейшем вам все равно понадобится создать свои кастомные
профили из Built-in профилей, когда вы захотите убрать/добавить правила
или изменить их настройки.

Отдельно нужно рассказать про Java профили. Дело в том, что для Java
существует 4 актуальных плагина:

-  коробочный sonar-java-plugin с профилем Sonar way, который
   используется по умолчанию
-  сторонний sonar-findbugs-plugin с 4-мя профилями
-  сторонний sonar-checkstyle-plugin без профилей
-  сторонний sonar-pmd-plugin без профилей

Таким образом, если вы установите все 4 плагина и оставите настройки
профилей без изменений – для проверки java кода будет
использоваться только Sonar way профиль, т.е. будет работать только
коробочный плагин, а 3 сторонних плагина будут бездействовать. Чтобы для проверки использовались все 4 плагина, я обычно создаю кастомный профиль,
который включает в себя правила из всех этих плагинов. Есть планы по добавлению этого кастомного java профиля в роль.

Следующий шаг – настройка **Quality Gates**. Это набор метрик, в соответсвии с которыми
проверка кода будет считаться успешной или не успешной. `Дефолтный набор <https://sonarcloud.io/organizations/lean-delivery/quality_gates/show/9>`_ проверяет процент покрытия кода,
процент дублирования кода, а также рейтинги Maintanability, Reliability, Security. Я обычно использую более упрощенный `кастомный набор <https://sonarcloud.io/organizations/lean-delivery/quality_gates/show/7770>`_,
во-первых потому что не всегда на проекте есть покрытие кода, во-вторых не всегда у команды есть ресурсы на исправление некритичных ошибок,
а поэтому рейтинги не нужны, достаточно просто не пропускать блокеры, критикалы (иногда мажоры). Есть планы по добавлению в роль возможности импорта кастомных наборов метрик.

Далее нужно привязать SonarQube к вашей CI системе. В этой статье я буду говорить о Jenkins. Во-первых, в меню **Administration > Configuration > Webhooks** нужно добавить вебхук на Jenkins
(или не нужно, если это уже было сделано ролью). Во-вторых, в самом Jenkins нужнo установить плагин SonarQube Scanner, затем в меню **Manage Jenkins > Configure System** добавить SonarQube Server и указать:

- имя (любое, в дальнейшем будет использоваться в пайплайне)
- ссылку по которой доступен SonarQube
- токен, который вы добавляли admin пользователю

Важный момент про ссылку. Если используется https, то тут есть 2 варианта. Если у вас нормальный сертификат, его надо предварительно указать в SonarQube плейбуке
(по умолчанию ставится самоподписанный). А если его нет и используется самоподписанный – вам придется импортировать его в Java, на которой работает Jenkins.

Кстати, для установки Jenkins я рекомендую использовать нашу роль `ansible-jenkins <https://github.com/lean-delivery/ansible-role-jenkins>`_, которая также может установить
вышеупомянутый плагин и добавить SonarQube в настройках. В планах – опубликовать плейбуку, которая устанавливает связку Jenkins - SonarQube и учитывает этот нюанс с сертификатом.

Иногда вместо плагина используют отдельно установленный `sonar-scanner <https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/>`_, а параметры запуска сканера указывают в файле sonar-project.properties.
На мой взгляд удобнее пользоваться плагином, а параметры запуска передавать прямо в пайплайне.

**Пайплайн.**

Итак рассмотрим ситуацию, когда у вас есть репозиторий с кодом, и вы используете простой git flow: есть главная ветка (develop/master), разработчики добавляют новый код в feature ветках и затем открывают пулл реквесты в главную ветку. Вы хотите использовать SonarQube для проверки как главной ветки, так и пулл реквестов.
Тут надо сразу сказать, что в бесплатном comminuty SonarQube отсутствует одна важная особенность, которая есть в платных версиях и в SonarCloud – это анализ веток и пулл реквестов в одном проекте. Т.е. в платных версиях и в SonarCloud одному репозиторию будет соответсвовать один проект, в котором анализируются и ветки и пулл реквесты. Вот пример:

.. image:: {filename}/images/sonarqube_project.png

А вот в бесплатной версии одному репозиторию будет соответсвовать много проектов, потому что придется создавать отдельный проект для главной ветки и для каждого пулл реквеста. И это достаточно неудобно, во-первых, потому что постоянно появляются новые пулл реквесты и вам рано или поздно придется задуматься о том, как автоматически удалять старые проекты. А во-вторых, если у вас несколько репозиториев, получится неразбериха из кучи проектов.
К счастью пока что есть более удобный способ организовать проверку пулл реквестов с помощью специальных плагинов, но работает он только для версии SonarQube 7.6 и ниже и к тому же не для всех репозиториев:

- для Github – не работает, `sonar-github-plugin <https://github.com/SonarSource/sonar-github>`_ перестал поддерживаться начиная с версии SonarQube 7.2. Теоретически должен работать с версией 7.1, но она уже достаточно устарела и вы не сможете использовать с ней свежие языковые плагины.
- для Bitbucket Server – работает с помощью `sonar-stash-plugin <https://github.com/AmadeusITGroup/sonar-stash/>`_
- для Bitbucket Cloud – работает с помощью `sonar-bitbucket-plugin <https://github.com/mibexsoftware/sonar-bitbucket-plugin>`_
- для Gitlab – работает с помощью `sonar-gitlab-plugin <https://github.com/mibexsoftware/sonar-bitbucket-plugin>`_
- для Azure DevOps – не работает, нет соответсвующего плагина

Суть способа в том, чтобы вообще не создавать проекты для пулл реквестов, а выводить информацию о всех найденных ошибках прямо в пулл реквест. Это выглядит например вот так:

.. image:: {filename}/images/sonarqube_pullrequest.png

И это супер удобно, потому что под каждой проблемной строкой появляется комментарий с описанием ошибки и ссылкой на правило в SonarQube, в котором практически всегда указано, как ее исправить.

Сравните этот способ по удобству с первым способом, когда для пулл реквеста создается проект (пример `здесь <https://github.com/epam/aws-syndicate/pull/51>`_), а для того чтобы увидеть в чем суть ошибки разработчику сначала придется сделать несколько кликов, чтобы в этот проект попасть (в примере нажмите View Details > SonarCloud Code Analysis Details > 6 Code Smells, затем кликните на одну из ошибок, чтобы понять к какой строке кода она относится).

Допустим, вы решили использовать второй способ - в SonarQube будет один проект для проверки главной ветки, а пулл реквесты будут проверяться без проекта. Вот здесь можно взять
`пайплайн <https://github.com/lean-delivery/ansible-role-sonarqube/blob/master/files/example_pipeline.groovy>`_ для запуска этих проверок.

**Как начать использовать на проекте.**

Для начала добавьте шаг с SonarQube анализом в сборку основной ветки, но так чтобы он никогда падал – уберите все метрики из Quality Gates.

В SonarQube появится проект с результатом проверки основной ветки. Очень часто вы можете там увидеть, что найдены тысячи или десятки тысяч ошибок и разобрать такое количество разработчикам будет нереально. Особенно это характерно для огромных репозиториев монолитных приложений. В этом случае нужно отключить правила, которые генерируют ошибку чуть ли не на каждый файл репозитория, или изменить порог их срабатывания, если он есть. Чтобы посмотреть, какие правила генерируют больше всего ошибок, в проекте перейдите к списку найденных ошибок и разверните фильтр Rule.

Например, у вас в репозитории 1000 файлов и для каждого из них сгенерировалась ошибка line too long, more than 80 chars. Вряд ли кто-то когда либо будет это исправлять. Лучше отключить такое правило или изменить ему порог срабатывания. Суть в том, чтобы оставить только уникальные ошибки, которые встречаются в некоторых файлах репозитория, но не во всех сразу. При этом обязательно сообщите разработчикам, какие правила вы отключили и какие изменили, возможно они что-то захотят вернуть обратно.

Далее попросите разработчиков посмотреть найденные блокеры, отключить правила для тех из них, которые они не будут исправлять, затем исправить все оставшиеся. Договоритесь о том, что с блокеры в главную ветку вы больше не пропускаете. Для этого добавьте в Quality Gates метрику Blocker issues is greater than 0. Теперь если в главной ветке появится блокер – сборка билда упадет. Если блокер вносится пулл реквестом, проверка пулл реквеста тоже упадет. Если есть возможность - стоит заблокировать мерж пулл реквеста при наличии упавшей проверки.

После блокеров точно такую же итерацию можно провести для критикалов, потом мажоров и т.д.

В пайплайне вы могли заметить такой параметр как COMMENT_SEVERITY, который показывает для каких ошибок SonarQube будет добавлять подстрочный комментарий (например, для всех критикалов
и старше, или для всех мажоров и старше). Если у вас в главной ветке много ошибок, я не рекомендую выставлять этот параметр в MINOR или INFO, иначе вы столкнетесь с ситуацией, когда
в каждом пулл реквесте будет сотня комментариев о минорных ошибках. Если вы в текущей итерации занимаетесь блокерами, то выставляйте этот параметр например равным CRITICAL. Получится, что блокеры вы не пропускаете, а комментарии будут выводится и для блокеров, и для критикалов.

Еще один совет – проверяйте с помощью SonarQube не только код разработчиков (бекенд и фронтенд), но и свой девопс код – плагины python, groovy, ansible, shellcheck вам в этом помогут.

**О чем не рассказано в этой статье.**

О добавлении code coverage статистики в SonarQube. Об OWASP плагине. О привязывании SonarQube к другим CI системам : Bamboo, Azure DevOps. О проверке maven, gradle и других проектов с помощью SonarQube. О радикальном исправлении ошибок по методу Сергея Подолицкого. 
Обо всем этом читайте в следующей части, только на lean-delivery.com.
