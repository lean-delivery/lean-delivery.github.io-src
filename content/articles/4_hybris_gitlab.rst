Infrastructure as Code. Why you need it.
##############################################
:date: 2020-03-23 13:00
:author: -
:tags: technical
:slug: hybris-gilab

----------------------------------

**1) интро - как мы пришли и какие проблемы решаем**
-
**2) архитектурная диаграмма, деплоймент view**

Наше решение, с инфраструктурной точки зрения, весьма обычно.
EC2 сервера, разделенные на целевые группы для фронтэнда и бэкэнда, балансируются AWS ALB.
Маршрутизация между целевыми группами организована через правила в AWS ALB.
.. image:: {filename}/images/hybris-diagram.png
Рис. 1 basic infra diagram

В качестве деплоймент стратегии был выбран Red/Black.
Работает это так:
 - Terraform создает новые EC2 сервера на основе нашего стандартного золотого AMI образа и добавляет их в соответствующие целевые группы
 - Ansible устанавливает необходимые пакеты и копирует файлы на новые сервера, запускает необходимые сервисы, обновляет базу данных
 - Старые сервера останавливаются и удаляются как только новые сервера признаны работающими корректно
.. image:: {filename}/images/red_black.png
Рис. 2

**3) approach limitation**

1. Hybris из за его внутренней реализации кластер групп - не помзволяет использовать для отказоустойивости класические автоскейлинг группы.
2. Требует пересмотра работы механизмов для четкого указания где должна выполняться бизнес логика - на какой из групп в кластере либо конкретном инстансе.
3. нет прямого доступа у разработчиков на каждую ноду в кластере hybris. доступ на ноду по SSH только через бастион.
4. во время релиза необходимо отклюить все бизнес процессы до момента переклюения
5. Переключение старого релиза и нового завязан на таргет группе ALB
6. Требует применения определенной стратегии бранчевания.
7. строгое ограничение правил создания тегов в гите(релиз продакшена по тегу)

**4) пайплайн, фича энвы**

Весь GitLab pipeline состоит из 2 частей CI/CD
.. image:: {filename}/images/gitLab-pipeline.png
Рис. 3
На каждый пушш в гит можно создать 1 фича енв в рамках одной ветки.(код приложения можно обновлять по каждому пушу в фича ветку)
	CI запускается после Git push.
	- первый этам запускаются в параель несколько наборов тестов(executeCodeQualityChecksCI, yunitinit, alltests)
	- на втором этапе в случае успешных всех тестов создается Hybris артифакт который в дальнейшем будет деплоиться на все необходимые окружения.
	CD часть (опционально вклюенеи авто деплоя)
	- берет ранее созданный артифакт Hybris в рамках пайплайна и деплоит с помощью Ансибла, Hybris приложение, предварительно подготовив терраформом всю инфроструктуру для фича окружения.
	- опционально Разаработчик может запустить смок тестирование на развернутое окружение.

Фича окружения представляют из себя полностью продакшен модель только с урезанным колличеством нод и шейпов. Данный тип окружений позволяет разработчикам и тестировщика проверить разработанный функционал в рамках своей фичи, не ожидая очереди когда код попадет в ветку девелоп и его установят на статическое окружения QA.

Весь LifeCycle представляет из себя следующую последовательность

Jira ticket -> New git branch(BAW-1331) -> inprogress ticket -> push after deveopment -> CI -> CD -> smoke tests - > New Merge Request -> code rewieiu -> waiting test ->intesting(manul test on depends) -> stop feature env -> wait for accept -> merge MR(develop) -> close

Branch stratage изображена на рисунке 1( рисунок branch stratage)
.. image:: {filename}/images/git_strategy.png

**5) terraform + ansible для non-prod/prod инфры**

Для реализации Red-Black Deployment с помощью Terraform мы обратимся к методологии Terraservice, описанному в этой статье `"статье" <https://lean-delivery.com/2019/12/infrastructure_as_code.html>`__..

Terraform код, отвечающий за создание EC2 серверов и добавляющий их в соответствующие целевые группы, примем как отдельный terraservice.
Причем отделим бэкэнд и фронтэнд друг от друга для более гибкого упраления релизами.
Добавим к имени terraform workspace хэш коммита, код из которого будет развернут на созданных EC2 серверах, чтобы идентифицировать релизы.

Допустим, наш предыдущий релиз бэкэнда был выполнен из коммита с хэшем 11111111, а следующий будет из коммита с хэшем 22222222.

Рис. 6 (как 1й, только сервера подписаны хэшем коммита)

Посмотрим, какие workspace существуют в Terraservice для бэкэнд нод:
::: default
    prod-us-east-1-11111111

Создадим новый workspace для хранения состояния новых EC2 серверов, на которые позже доставим код из коммита 22222222:
::: terraform workspace new prod-us-east-1-22222222

После выполнения команды apply для бэкэнд Terraservice в новом workspace инфраструктура будет выглядеть так:

Рис. 7 (как 2й, только сервера подписаны хэшем коммита)

Новые сервера не проходят AWS ALB healthchek, таким образом, на данный момент они исключены из балансировки.

Следующий шаг - доставка кода с помощью Ansible.
Для генерации динамического inventory файла для Ansible используем OpenSource проект terraform-inventory (https://github.com/adammck/terraform-inventory).

Рис. 8 (как 3й, только сервера подписаны хэшем коммита)

Итак, код из коммита с хэшем 22222222 доставлен на новые EC2 сервера. Теперь они проходят AWS ALB healthchek успешно и начали обслуживать запросы.

Похоже, жизненный цикл серверов с кодом из коммита с хэшем 11111111 подошел к концу, а это значит что их нужно удалять.
Для этого переключаемся в terraform workspace с именем prod-us-east-1-11111111 и выполняем destroy.

Рис. 9 (как 4й, только сервера подписаны хэшем коммита)


**6) бенефиты решения**

-